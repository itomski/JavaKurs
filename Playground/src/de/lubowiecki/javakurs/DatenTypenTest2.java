package de.lubowiecki.javakurs;

import java.util.ArrayList;
import java.util.List;

public class DatenTypenTest2 {

	public static String s = "Hallo";
	
	public static void main(String[] args) {
		
		// byte < short < int < long < float < double
		//         char < int
		
		long l;
		int i = 100;
		l = i; // widening von int zu long (automatisch) 
		double d;
		d = i; // widening von int zu double (automatisch)
		
		byte b = (byte) i; // narrowing von int zu byte (nicht automatisch, cast)
		
		double sum = i + d; // anpassung auf gleichen Typ, den höheren, widening von int zu double, erg ist vom höheren typ
		double erg = d * 2;
		
		 erg = i + l * d; // double
		 System.out.println(l * l); // long
		 System.out.println(i + b); // int
		
		 // Mathematische Operationen widen byte, short und char mind. auf ein int 
		 i = b + b; // erg mind. int
		 char c = 'a';
		 i = b + c; // byte und char widening zu int
		 
		 // increment, decrement und zusammengesetzte Operatoren (+=, -=, *=, /=, %=), 
		 // casten das erg in den ursprungstyp
		 // damit besteht die Gefahr für Informationsverlußt, Überlauf oder Unterlauf
		 b++; // b = (byte)(b + 1)
		 b += 10_000; // b = (byte)(b + 5)
		 System.out.println(b); // Überlauf (mehrfach)
		 
		 System.out.println("------ WRAPPER -------");
		 
		 // für jeden primitiven Datentyp gibt es eine Wrapper-Klasse
		 // byte > Byte
		 // short > Short
		 // char > Character
		 // int > Integer
		 // long > Long
		 // float > Float
		 // double > Double
		 
		 // Wrapper-Objekte sind immutable
		 
		 // Wrapper-Klassen bieten statische Methoden zum arbeiten mit dem jeweiligen Datentyp,
		 // Informationen zum jeweiligen Datentyp und Konvertierung zum und vom jeweiligen Datentyp
		 Integer.sum(10, 20);
		 Integer.parseInt("10");
		 Integer.toHexString(100);
		 
		 int a1 = 100;
		 int a2 = 100;
		 System.out.println(a1 == a2); // primitiver Vergleich
		 
		 System.out.println();
		 System.out.println(a1 == 100.5); // int wird zu double gewidet
		 
		 
		 System.out.println();
		 int i1 = 128;
		 Integer b1 = 128; // Zahlen von -128 bis 127 liegen im Byte-Lieteral-Pool
		 Integer b2 = 128;
		 Integer b3 = new Integer(120); // hier wird immer ein neues Objekt erzeugt
		 System.out.println(b1 == b2); // ist es das gleiche Objekt auf dem Heap
		 
		 // wird für Sortierung verwendet
		 System.out.println(Integer.compare(b1, b2)); // Wertevergleich, ist gleich/kleiner/größer?
		 
		 // Instanzmethoden zu Aktionen mit dem aktuellen Zustand des Objektes
		 System.out.println(b1.equals(b2)); // Wertevergleich, ja/nein
		 System.out.println(b1.compareTo(b2)); // Wertevergleich, ja/nein
		 
		 Double d2 = b1.doubleValue(); // Autoboxing von double zu Double
		 double d3 = b1.doubleValue();
		 
		 // Für Mathematische Operationen werden die Wrapper-Objekte ausgepackt/unboxing d.h. in primitive umgewandelt
		 System.out.println(d2 + d3);
		 
		 // Generische Typen (Typen in <...>)  sind IMMER komplexe Typen
		 List<Integer> zahlen = new ArrayList<>();
		 zahlen.add(10); // Autoboxing von int zu Integer
		 i1 = zahlen.get(0); // Auto-Unboxing
		 
		 System.out.println("-----------------");
		 
		 double d4 = i1; // primitiv widening von int zu double
		 //d2 = i1; // Error: int zuerst Autoboxing zu Integer und dann Klassaen-Widening zu Number was nicht zu Double passt 
		 // Wrappertypen sind zu einander nicht kompatibel, da sie Geschwisterelemente sind
		 
		 Number n = i1; // Autoboxing von int zu Integer und dann Objekt Promotion von Integer zu Number
		 
		 List<Double> zahlen2 = new ArrayList<>();
		 // zahlen2.add(100); // Autoboxing int zu Integer und Integer inkompatiel zu Double 
		 
		 double[] arr = new double[100];
		 arr[0] = 100; // primitiv widening von int zu double
		 
		 Double[] arr2 = new Double[100];
		 //arr2[0] = 100; // Error: Autoboing von int zu Integer
		 
		 int i5 = d2.intValue();
		 Byte b6 = Byte.parseByte("10");
		 
		 // Erste Aktion Autoboxing oder AutoUnboxing
		 double d7 = b6; // unboxing von Byte zu byte, primitive widening von byte zu double
		 
		 System.out.println("CompileTime-Konstante");
		 
		 final double customPI = 3.14;
		 // Kompiler ersetzt jedes Vorkommen von customPI durch die Zahl 3.14
		 // Stack muss nicht mehr überprüft werden
		 
		 System.out.println("RunTime-Konstante");
		 
		 final double customPI2;
		 customPI2 = 3.14d;
		// Jedes Vorkommen von customPI2 bleibt auch nach dem Kompilieren eine variable/konstante
		// wird auf dem Stack überprüft
		 
		 // Kompiler weiß erst zur Laufzeit, dass PI 3.14 und daher kann es aus seiner
		 // Sicht true oder false sein
		 while(customPI2 == 3.14) {  
			 break;
		 }
		 
		 System.out.println(Math.PI);
		 
		 // wird durch while(3.14 == 3.14) ersetzt
		 while(customPI == 3.14) { // Kompiler weiß, dass PI 3.14 ist und hoer immer true rauskommt
			 break;
		 }
		 //System.out.println("Hallo"); // Unerreichbare Anweisung
		 
		 
	}

}
